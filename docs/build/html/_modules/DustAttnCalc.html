
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DustAttnCalc &#8212; DustE 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for DustAttnCalc</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; DustAttnCalc</span>
<span class="sd">Given stellar masses, star formation rates, stellar metallicities, redshifts, axis ratios, calculate dust attenuation curves based on the hierarchical Bayesian model from Nagaraj+22a (in prep)</span>
<span class="sd">Author: Gautam Nagaraj--gxn75@psu.edu</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;regular_grid_interp_scipy&quot;</span><span class="p">,</span><span class="s2">&quot;mass_completeness&quot;</span><span class="p">,</span><span class="s2">&quot;get_dust_attn_curve_d2&quot;</span><span class="p">,</span><span class="s2">&quot;get_dust_attn_curve_d1&quot;</span><span class="p">,</span><span class="s2">&quot;getProspDataBasic&quot;</span><span class="p">,</span><span class="s2">&quot;marg_by_post&quot;</span><span class="p">,</span><span class="s2">&quot;getTraceInfo&quot;</span><span class="p">,</span><span class="s2">&quot;getModelSamplesI&quot;</span><span class="p">,</span><span class="s2">&quot;plotDustAttn&quot;</span><span class="p">,</span><span class="s2">&quot;plotDust12&quot;</span><span class="p">,</span><span class="s2">&quot;DustAttnCalc&quot;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">from</span> <span class="nn">sedpy.attenuation</span> <span class="kn">import</span> <span class="n">noll</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">truncnorm</span>
<span class="kn">import</span> <span class="nn">arviz</span> <span class="k">as</span> <span class="nn">az</span>
<span class="kn">import</span> <span class="nn">argparse</span> <span class="k">as</span> <span class="nn">ap</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">distutils.dir_util</span> <span class="kn">import</span> <span class="n">mkpath</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">RegularGridInterpolator</span> <span class="k">as</span> <span class="n">RGIScipy</span>
<span class="kn">from</span> <span class="nn">dynesty.utils</span> <span class="kn">import</span> <span class="n">resample_equal</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="s2">&quot;ticks&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set_style</span><span class="p">({</span><span class="s2">&quot;xtick.direction&quot;</span><span class="p">:</span> <span class="s2">&quot;in&quot;</span><span class="p">,</span><span class="s2">&quot;ytick.direction&quot;</span><span class="p">:</span> <span class="s2">&quot;in&quot;</span><span class="p">,</span>
               <span class="s2">&quot;xtick.top&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;ytick.right&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
               <span class="s2">&quot;xtick.major.size&quot;</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;xtick.minor.size&quot;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
               <span class="s2">&quot;ytick.major.size&quot;</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="s2">&quot;ytick.minor.size&quot;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
               <span class="p">})</span>

<div class="viewcode-block" id="regular_grid_interp_scipy"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.regular_grid_interp_scipy">[docs]</a><span class="k">def</span> <span class="nf">regular_grid_interp_scipy</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform a linear interpolation in N-dimensions w a regular grid</span>
<span class="sd">    The data must be defined on a filled regular grid, but the spacing may be</span>
<span class="sd">    uneven in any of the dimensions.</span>
<span class="sd">    This implementation uses the ``scipy.interpolate.RegularGridInterpolator`` class which, in turn, is</span>
<span class="sd">    based on the implementation from Johannes Buchner&#39;s ``regulargrid``</span>
<span class="sd">    package https://github.com/JohannesBuchner/regulargrid.</span>
<span class="sd">    Args:</span>
<span class="sd">        points: A list of vectors with shapes ``(m1,), ... (mn,)``. These</span>
<span class="sd">            define the grid points in each dimension.</span>
<span class="sd">        values: A tensor defining the values at each point in the grid</span>
<span class="sd">            defined by ``points``. This must have the shape</span>
<span class="sd">            ``(m1, ... mn, ..., nout)``.</span>
<span class="sd">        coords: A matrix defining the coordinates where the interpolation</span>
<span class="sd">            should be evaluated. This must have the shape ``(ntest, ndim)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rgi</span> <span class="o">=</span> <span class="n">RGIScipy</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">values</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rgi</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span></div>

<div class="viewcode-block" id="mass_completeness"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.mass_completeness">[docs]</a><span class="k">def</span> <span class="nf">mass_completeness</span><span class="p">(</span><span class="n">zred</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uses mass-completeness estimates from Tal+14, for FAST masses</span>
<span class="sd">    then applied M_PROSP / M_FAST to estimate Prospector completeness</span>
<span class="sd">    Credit: Joel Leja</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zred: 1-D Array of redshifts</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Minimum masses in ``log(M*/M_sun)`` for completeness at zred</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">zref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.65</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.1</span><span class="p">,</span><span class="mf">3.0</span><span class="p">])</span>
    <span class="n">mcomp_prosp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">8.71614882</span><span class="p">,</span><span class="mf">9.07108637</span><span class="p">,</span><span class="mf">9.63281923</span><span class="p">,</span><span class="mf">9.79486727</span><span class="p">,</span><span class="mf">10.15444536</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">zred</span><span class="p">,</span> <span class="n">zref</span><span class="p">,</span> <span class="n">mcomp_prosp</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_dust_attn_curve_d2"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.get_dust_attn_curve_d2">[docs]</a><span class="k">def</span> <span class="nf">get_dust_attn_curve_d2</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">d2</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate diffuse dust attenuation curve</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wave: Float or 1-D Array</span>
<span class="sd">        Wavelengths (Angstroms) at which attenuation curve should be evaluated</span>
<span class="sd">    n: Float</span>
<span class="sd">        Slope parameter of Noll+09 dust attenuation parametrization--difference between true slope and that of Calzetti+00 curve, with positive values signifying shallower curves</span>
<span class="sd">    d2: Float</span>
<span class="sd">        Diffuse dust optical depth; also referred to as tau throughout this document</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Diffuse dust attenuation curve at given wavelength(s) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Eb</span> <span class="o">=</span> <span class="mf">0.85</span> <span class="o">-</span> <span class="mf">1.9</span><span class="o">*</span><span class="n">n</span>
    <span class="k">return</span> <span class="n">noll</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span><span class="n">tau_v</span><span class="o">=</span><span class="n">d2</span><span class="p">,</span><span class="n">delta</span><span class="o">=</span><span class="n">n</span><span class="p">,</span><span class="n">c_r</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">Ebump</span><span class="o">=</span><span class="n">Eb</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_dust_attn_curve_d1"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.get_dust_attn_curve_d1">[docs]</a><span class="k">def</span> <span class="nf">get_dust_attn_curve_d1</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span><span class="n">d1</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate birth cloud dust attenuation curve</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wave: Float or 1-D Array</span>
<span class="sd">        Wavelengths (Angstroms) at which attenuation curve should be evaluated</span>
<span class="sd">    d1: Float</span>
<span class="sd">        Birth cloud dust optical depth</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Birth dust attenuation curve at given wavelength(s); inverse law from Charlot+Fall 00 assumed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">d1</span><span class="o">*</span><span class="p">(</span><span class="n">wave</span><span class="o">/</span><span class="mf">5500.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="getProspDataBasic"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.getProspDataBasic">[docs]</a><span class="k">def</span> <span class="nf">getProspDataBasic</span><span class="p">(</span><span class="n">numsamples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">numgal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get the Prospector posterior samples used to fit the model</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    numsamples: Integer</span>
<span class="sd">        Number of posterior samples per galaxy; do NOT change from 10 unless you request/have files with larger numbers of samples</span>
<span class="sd">    numgal: Integer</span>
<span class="sd">        Number of galaxies desired; if None, all mass-complete galaxies will be included</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obj: Dictionary</span>
<span class="sd">        Posterior samples of Prospector fits of 3D-HST galaxies, including stellar mass, SFR, etc.</span>
<span class="sd">    indfin: Integer array</span>
<span class="sd">        Indices giving locations of mass-complete galaxies (all or subset, depending on numgal)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;3dhst_samples_</span><span class="si">%d</span><span class="s2">_inc.pickle&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">numsamples</span><span class="p">),</span><span class="s1">&#39;rb&#39;</span><span class="p">))</span>
    <span class="n">logMavg</span><span class="p">,</span> <span class="n">ssfravg</span><span class="p">,</span> <span class="n">incavg</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;stellar_mass&#39;</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;ssfr_100&#39;</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;inc&#39;</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
    <span class="n">masscomp</span> <span class="o">=</span> <span class="n">mass_completeness</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="c1">#Get mass complete part of sample</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="n">logMavg</span><span class="o">&gt;=</span><span class="n">masscomp</span><span class="p">,</span><span class="n">ssfravg</span><span class="o">&gt;=-</span><span class="mf">12.5</span><span class="p">,</span><span class="n">incavg</span><span class="o">&gt;=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">incavg</span><span class="o">&lt;=</span><span class="mf">1.0</span><span class="p">))</span> <span class="c1">#Want mass-complete sample with reasonable masses, SFRs, and axis ratios</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">numgal</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span> <span class="n">numgal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
    <span class="n">indfin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">numgal</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">indfin</span></div>

<div class="viewcode-block" id="marg_by_post"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.marg_by_post">[docs]</a><span class="k">def</span> <span class="nf">marg_by_post</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">ind</span><span class="p">,</span><span class="n">proplist</span><span class="p">,</span><span class="n">mins</span><span class="p">,</span><span class="n">maxs</span><span class="p">,</span><span class="n">numsamples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">kdesamples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="n">weight_name</span><span class="o">=</span><span class="s1">&#39;pr_bv_1_eff_0&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Marginalize over variables not being considered but still in model; given the Monte Carlo nature of the model, this is done by randomly selecting values from the Prospector posterior distributions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj, ind: Output of getProspDataBasic</span>
<span class="sd">    proplist: List</span>
<span class="sd">        Variable names over which the marginalization is done; options include &#39;stellar_mass&#39;, &#39;sfr_100&#39; (current star formation rate), &#39;log_z_zsun&#39; (stellar metallicity), &#39;z&#39; (redshift), &#39;inc&#39; (axis ratio), &#39;dust1&#39; (birth cloud optical depth), &#39;dust2&#39; (diffuse dust optical depth), &#39;tau_eff&#39; (effective dust optical depth)</span>
<span class="sd">    mins, maxs: 1-D Numpy arrays</span>
<span class="sd">        Min, max values of the variables for marginalization; use the DustAttnCalc.get_indep_lims function for suitable limits</span>
<span class="sd">    numsamples: Integer</span>
<span class="sd">        Number of posterior samples per galaxy; do NOT change from 10 unless you request/have files with larger numbers of samples</span>
<span class="sd">    kdesamples: Integer</span>
<span class="sd">        Number of marginalized samples needed</span>
<span class="sd">    weight_name: String</span>
<span class="sd">        Name of weighting in the pickle file; this will be automatically determined in the DustAttnCalc class</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Input_arr: Array</span>
<span class="sd">        Random values from the Prospector posterior samples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># prior_prob = np.exp(obj[&#39;logp_prior&#39;][ind])</span>
    <span class="n">input_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">proplist</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">*</span><span class="n">numsamples</span><span class="p">))</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">*</span><span class="n">numsamples</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">proplist</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;stellar_mass&#39;</span> <span class="ow">or</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;sfr_100&#39;</span><span class="p">:</span> <span class="n">input_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">prop</span><span class="p">][</span><span class="n">ind</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">*</span><span class="n">numsamples</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">prop</span><span class="o">==</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">input_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">][:,</span><span class="kc">None</span><span class="p">],</span><span class="n">numsamples</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">*</span><span class="n">numsamples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">input_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="n">prop</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">*</span><span class="n">numsamples</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="n">cond</span><span class="p">,</span><span class="n">input_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">mins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">input_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">maxs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="n">input_arr</span> <span class="o">=</span> <span class="n">input_arr</span><span class="p">[:,</span><span class="n">cond</span><span class="p">]</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="n">weight_name</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">cond</span><span class="p">]</span>
    <span class="n">input_arr_mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">input_arr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_arr_mod</span><span class="p">)):</span>
        <span class="n">input_arr_mod</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">resample_equal</span><span class="p">(</span><span class="n">input_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">w</span><span class="p">)</span>
    <span class="n">inds_rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">size</span><span class="o">=</span><span class="n">kdesamples</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">input_arr_mod</span><span class="p">[:,</span><span class="n">inds_rand</span><span class="p">]</span></div>

<div class="viewcode-block" id="getTraceInfo"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.getTraceInfo">[docs]</a><span class="k">def</span> <span class="nf">getTraceInfo</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">bivar</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Parse the hierarchical Bayesian model trace object in order to get all samples of the model parameters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trace: Trace object</span>
<span class="sd">    bivar: Boolean</span>
<span class="sd">        Whether or not the model is bivariate (two dependent variables) or not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ngrid, taugrid: Multi-D Arrays</span>
<span class="sd">        Posterior samples of values of the dependent variables (n and/or tau) at the grid points in the interpolation model (taugrid = None if univariate model)</span>
<span class="sd">    log_width, log_width2: 1-D Arrays</span>
<span class="sd">        Posterior samples of the log_width parameters (log_width2 = None if univariate), which is a measure of the natural spread in reality around the model valuefs</span>
<span class="sd">    rho: 1-D Array</span>
<span class="sd">        Posterior samples of the correlation between the errors in ngrid and taugrid (None if univariate)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ngrid_0</span><span class="p">,</span> <span class="n">log_width_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span><span class="s1">&#39;ngrid&#39;</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span><span class="s1">&#39;log_width&#39;</span><span class="p">))</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">ngrid_0</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ngrid</span><span class="p">,</span> <span class="n">log_width</span> <span class="o">=</span> <span class="n">ngrid_0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">*</span><span class="n">sh</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">log_width_0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">bivar</span><span class="p">:</span>
        <span class="n">taugrid_0</span><span class="p">,</span> <span class="n">log_width2_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span><span class="s1">&#39;taugrid&#39;</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span><span class="s1">&#39;log_width2&#39;</span><span class="p">))</span>
        <span class="n">taugrid</span><span class="p">,</span> <span class="n">log_width2</span> <span class="o">=</span> <span class="n">taugrid_0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">*</span><span class="n">sh</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">log_width2_0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rho_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">posterior</span><span class="p">,</span><span class="s1">&#39;rho&#39;</span><span class="p">))</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">rho_0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">taugrid</span><span class="p">,</span> <span class="n">log_width2</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">log_width</span><span class="p">,</span> <span class="n">taugrid</span><span class="p">,</span> <span class="n">log_width2</span><span class="p">,</span> <span class="n">rho</span></div>

<div class="viewcode-block" id="getModelSamplesI"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.getModelSamplesI">[docs]</a><span class="k">def</span> <span class="nf">getModelSamplesI</span><span class="p">(</span><span class="n">xtup</span><span class="p">,</span> <span class="n">indep_samp</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">log_width</span><span class="p">,</span> <span class="n">taugrid</span><span class="p">,</span> <span class="n">log_width2</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">numsamp</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">nlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">taulim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_other</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate samples of n and/or tau (the dependent variables of the model) at a given set of points</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xtup: List of arrays</span>
<span class="sd">        Values of grid points for independent variables in the model; use DustAttnCalc.getPostModelData() for easy generation</span>
<span class="sd">    indep_samp: 2-D or 3-D array</span>
<span class="sd">        Points at which to evaluate model; variables are differentiated at the outermost dimension; for example, in a 2-D case, each row is a different variable</span>
<span class="sd">    ngrid, log_width, taugrid, log_width2, rho: Outputs of getTraceInfo</span>
<span class="sd">    numsamp: Integer</span>
<span class="sd">        Number of samples desired per galaxy</span>
<span class="sd">    nlim, taulim: Two-element 1-D arrays</span>
<span class="sd">        Limits for n and tau to keep sample values within reasonable bounds; see DustAttnCalc.make_prop_dict() for values to use; those bounds can be guaranteed only if the independent variables are within the correct bounds as well</span>
<span class="sd">    return_other: Boolean</span>
<span class="sd">        Whether or not to also return Gaussian width and bivariate correlation parameter values </span>
<span class="sd">    </span>
<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    n_sim, tau_sim: 2-D or 3-D arrays (same dimension as indep_samp but different outer dimension size)</span>
<span class="sd">        Samples of n and/or tau at the given points; tau_sim is None if univariate</span>
<span class="sd">    width, width2, rho: 1-D Arrays</span>
<span class="sd">        Samples of Gaussian width and bivariate correlation if desired</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_width</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">indep_samp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">indepI</span> <span class="o">=</span> <span class="n">indep_samp</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">indepI</span> <span class="o">=</span> <span class="n">indep_samp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indep_samp</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">indep_samp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">numsamp</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indep_samp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">sh</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">numsamp</span><span class="p">)</span>
    <span class="n">n_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sh</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">taugrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tau_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sh</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">tau_sim</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
        <span class="n">ngrid_mod</span><span class="p">,</span> <span class="n">width_mod</span> <span class="o">=</span> <span class="n">ngrid</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_width</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
        <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">n_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">n_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">interp_part</span> <span class="o">=</span> <span class="n">regular_grid_interp_scipy</span><span class="p">(</span><span class="n">xtup</span><span class="p">,</span> <span class="n">ngrid_mod</span><span class="p">,</span> <span class="n">indepI</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># Direct model values (without adding a random component to represent the natural error in the model)</span>
        <span class="n">n_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp_part</span> <span class="o">+</span> <span class="n">width_mod</span> <span class="o">*</span> <span class="n">r1</span> <span class="c1"># Simulated values include the direct interpolated model values plus a random component based on the width parameter</span>
        <span class="c1"># Try to ensure that all samples of n are within the desired bounds, but ignore if there are direct model values (without adding a random component) that are considerably below or above the limits</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">interp_part</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">nlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">0.1</span><span class="o">*</span><span class="n">width_mod</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">interp_part</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">nlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.1</span><span class="o">*</span><span class="n">width_mod</span><span class="p">:</span>
            <span class="n">ind_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">n_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_bad</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">r1</span><span class="p">[</span><span class="n">ind_bad</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_bad</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">n_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp_part</span> <span class="o">+</span> <span class="n">width_mod</span> <span class="o">*</span> <span class="n">r1</span>
                <span class="n">ind_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">n_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># Repeat the same process for tau if bivariate model</span>
        <span class="k">if</span> <span class="n">taugrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">taugrid_mod</span><span class="p">,</span> <span class="n">width2_mod</span><span class="p">,</span> <span class="n">rho_mod</span> <span class="o">=</span> <span class="n">taugrid</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_width2</span><span class="p">[</span><span class="n">ind</span><span class="p">]),</span> <span class="n">rho</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">interp_part</span> <span class="o">=</span> <span class="n">regular_grid_interp_scipy</span><span class="p">(</span><span class="n">xtup</span><span class="p">,</span> <span class="n">taugrid_mod</span><span class="p">,</span> <span class="n">indepI</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tau_sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">tau_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp_part</span> <span class="o">+</span> <span class="n">width2_mod</span> <span class="o">*</span> <span class="p">(</span><span class="n">rho_mod</span><span class="o">*</span><span class="n">r1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">rho_mod</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">r2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">interp_part</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">taulim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">0.1</span><span class="o">*</span><span class="n">width2_mod</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">interp_part</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">taulim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.1</span><span class="o">*</span><span class="n">width2_mod</span><span class="p">:</span>
                <span class="n">ind_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">tau_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">taulim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tau_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">taulim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_bad</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">r2</span><span class="p">[</span><span class="n">ind_bad</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_bad</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">tau_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp_part</span> <span class="o">+</span> <span class="n">width2_mod</span> <span class="o">*</span> <span class="p">(</span><span class="n">rho_mod</span><span class="o">*</span><span class="n">r1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">rho_mod</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">r2</span><span class="p">)</span>
                    <span class="n">ind_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">tau_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">taulim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tau_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">taulim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_other</span><span class="p">:</span> <span class="k">return</span> <span class="n">n_sim</span><span class="p">,</span> <span class="n">tau_sim</span>
    <span class="k">if</span> <span class="n">taugrid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">n_sim</span><span class="p">,</span> <span class="n">tau_sim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_width</span><span class="p">[</span><span class="n">inds</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_width2</span><span class="p">[</span><span class="n">inds</span><span class="p">]),</span> <span class="n">rho</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">n_sim</span><span class="p">,</span> <span class="n">tau_sim</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_width</span><span class="p">[</span><span class="n">inds</span><span class="p">]),</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="plotDustAttn"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.plotDustAttn">[docs]</a><span class="k">def</span> <span class="nf">plotDustAttn</span><span class="p">(</span><span class="n">nvals</span><span class="p">,</span><span class="n">tauvals</span><span class="p">,</span><span class="n">img_name</span><span class="p">,</span><span class="n">wvs</span><span class="p">,</span><span class="n">effective</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Plot either diffuse or effective dust attenuation curves</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nvals, tauvals: 1-D Arrays</span>
<span class="sd">        Samples of n and tau for 1 galaxy only</span>
<span class="sd">    img_name: String</span>
<span class="sd">        Name for image (can choose desired extension, but if vector graphics format, will need to remove the dpi argument)</span>
<span class="sd">    wvs: 1-D Array</span>
<span class="sd">        Array of wavelengths (in Angstroms) at which dust attenuation curve will be plotted</span>
<span class="sd">    effective: Boolean</span>
<span class="sd">        Whether or not effective dust (or diffuse dust if False) is the quantity in question</span>
<span class="sd">    label: String</span>
<span class="sd">        Text to help describe plot; optimally a list of independent variable values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">lnv</span><span class="p">,</span> <span class="n">lwv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">wvs</span><span class="p">)</span>
    <span class="n">attn_curve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">lnv</span><span class="p">,</span><span class="n">lwv</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lnv</span><span class="p">):</span>
        <span class="n">attn_curve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_dust_attn_curve_d2</span><span class="p">(</span><span class="n">wvs</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">nvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">d2</span><span class="o">=</span><span class="n">tauvals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">attn_mean</span><span class="p">,</span> <span class="n">attn_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">attn_curve</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">attn_curve</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wvs</span><span class="p">,</span><span class="n">attn_mean</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">wvs</span><span class="p">,</span><span class="n">attn_mean</span><span class="o">-</span><span class="n">attn_std</span><span class="p">,</span><span class="n">attn_mean</span><span class="o">+</span><span class="n">attn_std</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\lambda$ ($\AA$)&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">effective</span><span class="p">:</span> <span class="n">taustr</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_{\lambda,{\rm eff}}$&quot;</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">taustr</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_{\lambda,2}$&quot;</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">taustr</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">wvs</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">wvs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;x-small&#39;</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">img_name</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span></div>

<div class="viewcode-block" id="plotDust12"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.plotDust12">[docs]</a><span class="k">def</span> <span class="nf">plotDust12</span><span class="p">(</span><span class="n">tau1</span><span class="p">,</span><span class="n">tau2</span><span class="p">,</span><span class="n">img_name</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">wvs</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Plot either diffuse or effective dust attenuation curves</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tau1, tau2, n: 1-D Arrays</span>
<span class="sd">        Samples of birth cloud dust optical depth (tau1), diffuse dust optical depth (tau2), and dust slope index (n) for 1 galaxy only</span>
<span class="sd">    img_name: String</span>
<span class="sd">        Name for image (can choose desired extension, but if vector graphics format, will need to remove the dpi argument)</span>
<span class="sd">    wvs: 1-D Array</span>
<span class="sd">        Array of wavelengths (in Angstroms) at which dust attenuation curve will be plotted</span>
<span class="sd">    label: String</span>
<span class="sd">        Text to help describe plot; optimally a list of independent variable values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ltau</span><span class="p">,</span> <span class="n">lwv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tau1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">wvs</span><span class="p">)</span>
    <span class="n">attn_curve1</span><span class="p">,</span> <span class="n">attn_curve2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">ltau</span><span class="p">,</span><span class="n">lwv</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">ltau</span><span class="p">,</span><span class="n">lwv</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ltau</span><span class="p">):</span>
        <span class="n">attn_curve1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_dust_attn_curve_d1</span><span class="p">(</span><span class="n">wvs</span><span class="p">,</span><span class="n">d1</span><span class="o">=</span><span class="n">tau1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">attn_curve2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_dust_attn_curve_d2</span><span class="p">(</span><span class="n">wvs</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">d2</span><span class="o">=</span><span class="n">tau2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">attn1_mean</span><span class="p">,</span> <span class="n">attn1_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">attn_curve1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">attn_curve1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">attn2_mean</span><span class="p">,</span> <span class="n">attn2_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">attn_curve2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">attn_curve2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wvs</span><span class="p">,</span><span class="n">attn1_mean</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_{\lambda,1}$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">wvs</span><span class="p">,</span><span class="n">attn1_mean</span><span class="o">-</span><span class="n">attn1_std</span><span class="p">,</span><span class="n">attn1_mean</span><span class="o">+</span><span class="n">attn1_std</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wvs</span><span class="p">,</span><span class="n">attn2_mean</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_{\lambda,2}$&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">wvs</span><span class="p">,</span><span class="n">attn2_mean</span><span class="o">-</span><span class="n">attn2_std</span><span class="p">,</span><span class="n">attn2_mean</span><span class="o">+</span><span class="n">attn2_std</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\lambda$ ($\AA$)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_{\lambda}$&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.15</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;x-small&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">wvs</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">wvs</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">img_name</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span></div>

<div class="viewcode-block" id="DustAttnCalc"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc">[docs]</a><span class="k">class</span> <span class="nc">DustAttnCalc</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Primary mechanism for getting dust attenuation curves &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">f1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">f2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">bv</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">eff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">samples</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">wv_arr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1500.0</span><span class="p">,</span><span class="mf">5000.0</span><span class="p">,</span><span class="mi">501</span><span class="p">),</span><span class="n">img_dir_orig</span><span class="o">=</span><span class="s1">&#39;TraceFiles&#39;</span><span class="p">,</span><span class="n">logM</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sfr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">logZ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">d2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">de</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize the DustAttnCalc Class; independent variables can be passed through files or direct arrays</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f1: String (Optional)</span>
<span class="sd">            Name of file with independent variable values</span>
<span class="sd">        f2: String (Optional)</span>
<span class="sd">            Name of file with diffuse dust values in order to get birth cloud dust values</span>
<span class="sd">        bv: Boolean</span>
<span class="sd">            Whether or not a bivariate model is desired</span>
<span class="sd">        eff: Boolean</span>
<span class="sd">            Whether or not the model should be for effective or diffuse dust</span>
<span class="sd">        samples: Integer</span>
<span class="sd">            Number of samples per galaxy desired for dependent variables</span>
<span class="sd">        wv_arr: 1-D Array</span>
<span class="sd">            Wavelengths (Angstroms) at which dust attenuation curves should be calculated</span>
<span class="sd">        img_dir_orig: String</span>
<span class="sd">            Name of directory with the trace netcdf and data files: default in the package is TraceFiles</span>
<span class="sd">        logM, sfr, logZ, z, i, d2, de: Preferably 1-D (but possibly 2-D) arrays or NoneType (Optional)</span>
<span class="sd">            Values of independent variables that you have; any subset is allowed, but d2 and de are reserved for univariate models (for diffuse and effective dust, respectively)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2_file</span> <span class="o">=</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bivar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective</span> <span class="o">=</span> <span class="n">bv</span><span class="p">,</span> <span class="n">eff</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bivar</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;logM&#39;</span><span class="p">,</span><span class="s1">&#39;sfr&#39;</span><span class="p">,</span><span class="s1">&#39;logZ&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;i&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;logM&#39;</span><span class="p">,</span><span class="s1">&#39;sfr&#39;</span><span class="p">,</span><span class="s1">&#39;logZ&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;de&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;logM&#39;</span><span class="p">,</span><span class="s1">&#39;sfr&#39;</span><span class="p">,</span><span class="s1">&#39;logZ&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;d2&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logM_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfr_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logZ_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_arr</span> <span class="o">=</span> <span class="n">logM</span><span class="p">,</span> <span class="n">sfr</span><span class="p">,</span> <span class="n">logZ</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d2_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">de_arr</span> <span class="o">=</span> <span class="n">d2</span><span class="p">,</span> <span class="n">de</span>
        <span class="k">if</span> <span class="n">f1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_indep_file</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">f2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_d2_file</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wv_arr</span> <span class="o">=</span> <span class="n">samples</span><span class="p">,</span> <span class="n">wv_arr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_dir_orig</span> <span class="o">=</span> <span class="n">img_dir_orig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_prop_dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_creation</span><span class="p">()</span>

<div class="viewcode-block" id="DustAttnCalc.label_creation"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.label_creation">[docs]</a>    <span class="k">def</span> <span class="nf">label_creation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create appropriate labels for plots and bookkeeping; called during initialization of DustAttnCalc Class &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">:</span> <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prop</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">indepext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="s1">&#39;sfr&#39;</span><span class="p">,</span><span class="s1">&#39;logZ&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;d1&#39;</span><span class="p">,</span><span class="s1">&#39;d2&#39;</span><span class="p">,</span><span class="s1">&#39;de&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indep_pickle_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_lab</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataname</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indep_pickle_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;pickle_names&#39;</span><span class="p">][</span><span class="n">name</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">][</span><span class="n">name</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indep_lab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">][</span><span class="n">name</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataname</span><span class="o">+=</span><span class="n">indepext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indep_pickle_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indep_pickle_name</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">:</span> <span class="n">nstr</span><span class="p">,</span> <span class="n">taustr</span> <span class="o">=</span> <span class="s1">&#39;ne&#39;</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">nstr</span><span class="p">,</span> <span class="n">taustr</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;tau2&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bivar</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataname</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;n_d2&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataname</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_n&#39;</span>
            <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataname</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;_d2&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extratext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataname</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">dep_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_lab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">][</span><span class="n">nstr</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">][</span><span class="n">nstr</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dep_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_lab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">][</span><span class="n">taustr</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">][</span><span class="n">taustr</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">][</span><span class="n">nstr</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">][</span><span class="n">nstr</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taulim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">][</span><span class="n">taustr</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">][</span><span class="n">taustr</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">taustr</span> <span class="o">=</span> <span class="n">nstr</span><span class="p">,</span> <span class="n">taustr</span></div>
        
<div class="viewcode-block" id="DustAttnCalc.make_prop_dict"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.make_prop_dict">[docs]</a>    <span class="k">def</span> <span class="nf">make_prop_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create dictionaries with names, labels, and reasonable limits for parameters; called during initialization of DustAttnCalc Class &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;logM&#39;</span><span class="p">:</span> <span class="s1">&#39;logM&#39;</span><span class="p">,</span> <span class="s1">&#39;sfr&#39;</span><span class="p">:</span> <span class="s1">&#39;logSFR&#39;</span><span class="p">,</span> <span class="s1">&#39;logZ&#39;</span><span class="p">:</span> <span class="s1">&#39;logZ&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="s1">&#39;axis_ratio&#39;</span><span class="p">,</span> <span class="s1">&#39;d1&#39;</span><span class="p">:</span><span class="s1">&#39;dust1&#39;</span><span class="p">,</span> <span class="s1">&#39;d2&#39;</span><span class="p">:</span><span class="s1">&#39;dust2&#39;</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span><span class="s1">&#39;duste&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tau2&#39;</span><span class="p">:</span> <span class="s1">&#39;dust2&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span> <span class="s1">&#39;duste&#39;</span><span class="p">,</span> <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="s1">&#39;ne&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;logM&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s1">&#39;$\log M_*$&#39;</span><span class="p">,</span> <span class="s1">&#39;sfr&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s1">&#39;$\log$ SFR$_{\rm</span><span class="si">{100}</span><span class="s1">}$&#39;</span><span class="p">,</span> <span class="s1">&#39;logZ&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s1">&#39;$\log (Z/Z_\odot)$&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="sa">r</span><span class="s1">&#39;$b/a$&#39;</span><span class="p">,</span> <span class="s1">&#39;d1&#39;</span><span class="p">:</span><span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_</span><span class="si">{1}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="s1">&#39;d2&#39;</span><span class="p">:</span><span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_</span><span class="si">{2}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span><span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_{\rm </span><span class="si">{eff}</span><span class="s2">}$&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tau2&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_</span><span class="si">{2}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;$\hat{\tau}_{\rm </span><span class="si">{eff}</span><span class="s2">}$&quot;</span><span class="p">,</span> <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;$n_{\rm </span><span class="si">{eff}</span><span class="s2">}$&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;pickle_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;logM&#39;</span><span class="p">:</span> <span class="s1">&#39;stellar_mass&#39;</span><span class="p">,</span> <span class="s1">&#39;sfr&#39;</span><span class="p">:</span> <span class="s1">&#39;sfr_100&#39;</span><span class="p">,</span> <span class="s1">&#39;logZ&#39;</span><span class="p">:</span> <span class="s1">&#39;log_z_zsun&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="s1">&#39;inc&#39;</span><span class="p">,</span> <span class="s1">&#39;d1&#39;</span><span class="p">:</span><span class="s1">&#39;dust1&#39;</span><span class="p">,</span> <span class="s1">&#39;d2&#39;</span><span class="p">:</span><span class="s1">&#39;dust2&#39;</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span><span class="s1">&#39;tau_eff&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;pickle_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tau2&#39;</span><span class="p">:</span> <span class="s1">&#39;dust2&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;dust_index&#39;</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span> <span class="s1">&#39;tau_eff&#39;</span><span class="p">,</span> <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="s1">&#39;n_eff&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;logM&#39;</span><span class="p">:</span> <span class="mf">8.74</span><span class="p">,</span> <span class="s1">&#39;sfr&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">2.06</span><span class="p">,</span> <span class="s1">&#39;logZ&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.70</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mf">0.51</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="mf">0.09</span><span class="p">,</span> <span class="s1">&#39;d1&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span> <span class="s1">&#39;d2&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;logM&#39;</span><span class="p">:</span> <span class="mf">11.30</span><span class="p">,</span> <span class="s1">&#39;sfr&#39;</span><span class="p">:</span> <span class="mf">2.11</span><span class="p">,</span> <span class="s1">&#39;logZ&#39;</span><span class="p">:</span> <span class="mf">0.18</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mf">2.83</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="mf">0.97</span><span class="p">,</span> <span class="s1">&#39;d1&#39;</span><span class="p">:</span> <span class="mf">2.23</span><span class="p">,</span> <span class="s1">&#39;d2&#39;</span><span class="p">:</span> <span class="mf">1.95</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span> <span class="mf">2.19</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tau2&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.4</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tau2&#39;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="s1">&#39;de&#39;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">}</span></div>

<div class="viewcode-block" id="DustAttnCalc.read_indep_file"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.read_indep_file">[docs]</a>    <span class="k">def</span> <span class="nf">read_indep_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read independent variable file for univariate or bivariate models; called during initialization of DustAttnCalc Class &quot;&quot;&quot;</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">Table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">dat</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span> <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prop</span><span class="o">+</span><span class="s1">&#39;_arr&#39;</span><span class="p">,</span><span class="n">dat</span><span class="p">[</span><span class="n">prop</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span> <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prop</span><span class="o">+</span><span class="s1">&#39;_arr&#39;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="DustAttnCalc.read_d2_file"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.read_d2_file">[docs]</a>    <span class="k">def</span> <span class="nf">read_d2_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read independent variable file for diffuse dust values which can be used in generating birth cloud dust values; called during initialization of DustAttnCalc Class &quot;&quot;&quot;</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">Table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d2_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d2_arr</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[</span><span class="s1">&#39;d2&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="DustAttnCalc.get_indep"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.get_indep">[docs]</a>    <span class="k">def</span> <span class="nf">get_indep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">indep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">prop_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Figure out which indices are included as independent variables and which ones need to be marginalized over: called by run_dust_modules, the primary method in the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mins</span><span class="p">,</span> <span class="n">maxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indep_lims</span><span class="p">()</span>
        <span class="n">inds</span><span class="p">,</span> <span class="n">inds_not</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">mins_not</span><span class="p">,</span> <span class="n">maxs_not</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="k">assert</span> <span class="n">prop_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Didn&#39;t provide variable name list!&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">):</span>
            <span class="n">prop_arr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prop</span><span class="o">+</span><span class="s1">&#39;_arr&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">prop_arr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">prop_list</span>
            <span class="k">if</span> <span class="n">cond</span><span class="p">:</span> 
                <span class="n">inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prop_arr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indep</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">inds_not</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">mins_not</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mins</span><span class="p">[</span><span class="n">prop</span><span class="p">])</span>
                <span class="n">maxs_not</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxs</span><span class="p">[</span><span class="n">prop</span><span class="p">])</span>
        <span class="n">inds</span><span class="p">,</span> <span class="n">inds_not</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inds</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inds_not</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inds</span><span class="p">,</span> <span class="n">inds_not</span><span class="p">,</span> <span class="n">mins_not</span><span class="p">,</span> <span class="n">maxs_not</span></div>

<div class="viewcode-block" id="DustAttnCalc.run_dust_modules"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.run_dust_modules">[docs]</a>    <span class="k">def</span> <span class="nf">run_dust_modules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">indep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">prop_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Run all necessary modules to provide values of the dependent variables given the independent variables. The independent variable list can be provided directly or taken from initialization.</span>
<span class="sd">        </span>
<span class="sd">        Parameters (Optional)</span>
<span class="sd">        ---------------------</span>
<span class="sd">        indep: 2-D (or possibly 3-D) array</span>
<span class="sd">            Array of points in the independent parameter space, with variable distinction on the outer dimension; can be just a subset of the variables used in the model itself. For example, to include just logM and SFR, you can make a two-row array with values of logM and SFR and indicate the proper labels with prop_list</span>
<span class="sd">        prop_list: List of strings</span>
<span class="sd">            Names of variables corresponding to indep; options are &#39;logM&#39; (stellar mass), &#39;sfr&#39; (current star formation rate), &#39;logZ&#39; (stellar metallicity), &#39;z&#39; (redshift), &#39;i&#39; (inclination), &#39;d2&#39; (diffuse dust optical depth), &#39;de&#39; (effective dust optical depth)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inds</span><span class="p">,</span> <span class="n">inds_not</span><span class="p">,</span> <span class="n">mins_not</span><span class="p">,</span> <span class="n">maxs_not</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indep</span><span class="p">(</span><span class="n">indep</span><span class="p">,</span><span class="n">prop_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inds</span> <span class="o">=</span> <span class="n">inds</span>
        <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">(</span><span class="n">prop_list</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">ngal</span><span class="p">))</span>   
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">indep</span><span class="p">)</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds_not</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> 
            <span class="n">obj</span><span class="p">,</span> <span class="n">indfin</span> <span class="o">=</span> <span class="n">getProspDataBasic</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indep_samp</span><span class="p">[</span><span class="n">inds_not</span><span class="p">]</span> <span class="o">=</span> <span class="n">marg_by_post</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">indfin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_pickle_name</span><span class="p">[</span><span class="n">inds_not</span><span class="p">],</span><span class="n">mins_not</span><span class="p">,</span> <span class="n">maxs_not</span><span class="p">,</span> <span class="n">kdesamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ngal</span><span class="p">,</span> <span class="n">weight_name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;pr_bv_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bivar</span><span class="si">}</span><span class="s1">_eff_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="n">inds</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_samp</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prop</span><span class="o">+</span><span class="s1">&#39;_arr&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_samp</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">indep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">trace</span><span class="p">,</span> <span class="n">xtup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPostModelData</span><span class="p">()</span>
        <span class="n">ngrid</span><span class="p">,</span> <span class="n">log_width</span><span class="p">,</span> <span class="n">taugrid</span><span class="p">,</span> <span class="n">log_width2</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="n">getTraceInfo</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">bivar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bivar</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bivar</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span> <span class="n">nlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taulim</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">nlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlim</span>
        <span class="n">n_sim</span><span class="p">,</span> <span class="n">tau_sim</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">w2s</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">getModelSamplesI</span><span class="p">(</span><span class="n">xtup</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_samp</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">log_width</span><span class="p">,</span> <span class="n">taugrid</span><span class="p">,</span> <span class="n">log_width2</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">nlim</span><span class="o">=</span><span class="n">nlim</span><span class="p">,</span> <span class="n">taulim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taulim</span><span class="p">,</span> <span class="n">return_other</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">numsamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_sim</span><span class="p">,</span> <span class="n">tau_sim</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">w2s</span><span class="p">,</span> <span class="n">rs</span></div>

<div class="viewcode-block" id="DustAttnCalc.get_d1"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.get_d1">[docs]</a>    <span class="k">def</span> <span class="nf">get_d1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">d2</span><span class="p">,</span><span class="n">totnum</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span><span class="n">tau_sim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get birth cloud dust optical depth from diffuse dust optical depth</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d2: 1-D Array</span>
<span class="sd">            Diffuse dust optical depths at which you want the birth cloud dust optical depths</span>
<span class="sd">        totnum: Integer</span>
<span class="sd">            Internal parameter; no need for adjustment</span>
<span class="sd">        tau_sim: 2-D (or possibly 3-D) array</span>
<span class="sd">            Optional array of posterior diffuse dust optical depth values (for the dust1-dust2 hierarchical Bayesian model) to save time in the calculation; used when several iterations of get_d1 are required in plotDust()</span>
<span class="sd">        </span>
<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        d1ret: 2-D array</span>
<span class="sd">            Samples of birth cloud dust optical depth corresponding to d2</span>
<span class="sd">        tau_sim: 2-D (or possibly 3-D) array</span>
<span class="sd">            Posterior samples of diffuse dust from the dust1-dust2 model; returned if tau_sim wasn&#39;t already provided to the function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ext</span><span class="p">,</span> <span class="n">indep_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extratext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extratext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span> <span class="o">=</span> <span class="s1">&#39;d1_d2&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;dust1&#39;</span><span class="p">]</span>
        <span class="n">d1min</span><span class="p">,</span> <span class="n">d1max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">][</span><span class="s1">&#39;d1&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">][</span><span class="s1">&#39;d1&#39;</span><span class="p">]</span>
        <span class="n">indep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">d1min</span><span class="p">,</span><span class="n">d1max</span><span class="p">,</span><span class="n">totnum</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]</span>
        <span class="k">if</span> <span class="n">tau_sim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">already_calc</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">trace</span><span class="p">,</span> <span class="n">xtup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPostModelData</span><span class="p">()</span>
            <span class="n">ngrid</span><span class="p">,</span> <span class="n">log_width</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">getTraceInfo</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">bivar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tau_sim</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">getModelSamplesI</span><span class="p">(</span><span class="n">xtup</span><span class="p">,</span> <span class="n">indep</span><span class="p">,</span> <span class="n">ngrid</span><span class="p">,</span> <span class="n">log_width</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nlim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">taulim</span><span class="p">,</span> <span class="n">numsamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">already_calc</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">d1ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tau_sim</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tau_sim</span><span class="p">)):</span>
            <span class="n">indsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">tau_sim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">d1ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span><span class="n">tau_sim</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">indsort</span><span class="p">],</span><span class="n">indep</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">indsort</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extratext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span> <span class="o">=</span> <span class="n">ext</span><span class="p">,</span> <span class="n">indep_name</span>
        <span class="k">if</span> <span class="n">already_calc</span><span class="p">:</span> <span class="k">return</span> <span class="n">d1ret</span>
        <span class="k">return</span> <span class="n">d1ret</span><span class="p">,</span> <span class="n">tau_sim</span></div>

<div class="viewcode-block" id="DustAttnCalc.getPostModelData"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.getPostModelData">[docs]</a>    <span class="k">def</span> <span class="nf">getPostModelData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read appropriate .netcdf and .dat files given model requirements to initiate the trace parsing process</span>
<span class="sd">        </span>
<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        trace: Trace object</span>
<span class="sd">        xtup: List of arrays</span>
<span class="sd">            Unique values of coordinates of grid points in each parameter dimension used in the given hierarchical Bayesian model; the true grid is created using np.meshgrid(*xtup)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">globsearch</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_dir_orig</span><span class="p">,</span><span class="s1">&#39;*</span><span class="si">%s</span><span class="s1">*eff_</span><span class="si">%d</span><span class="s1">*.nc&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extratext</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">))</span>
        <span class="n">nclist</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">globsearch</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nclist</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No netcdf file found in glob search&quot;</span><span class="p">,</span><span class="n">globsearch</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nclist</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Multiple files or directories found in search&quot;</span><span class="p">,</span><span class="n">globsearch</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">az</span><span class="o">.</span><span class="n">from_netcdf</span><span class="p">(</span><span class="n">nclist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Trace file:&quot;</span><span class="p">,</span> <span class="n">nclist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">globsearch</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_dir_orig</span><span class="p">,</span><span class="s1">&#39;*</span><span class="si">%s</span><span class="s1">*eff_</span><span class="si">%d</span><span class="s1">*.dat&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extratext</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">))</span>
        <span class="n">datf</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">globsearch</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">Table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">datf</span><span class="p">,</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dat file:&quot;</span><span class="p">,</span><span class="n">datf</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span><span class="p">)</span>
        <span class="n">name_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="n">name_0</span><span class="p">])</span>
        <span class="n">grid_len</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">size</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Measured grid length from file:&quot;</span><span class="p">,</span> <span class="n">grid_len</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">ndim</span><span class="p">,</span><span class="n">grid_len</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indep_name</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">trace</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="DustAttnCalc.calcDust"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.calcDust">[docs]</a>    <span class="k">def</span> <span class="nf">calcDust</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">indep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">prop_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">img_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">img_dir</span><span class="o">=</span><span class="s1">&#39;DustAttnCurves&#39;</span><span class="p">,</span><span class="n">max_num_plot</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">plot_tau</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Plot dust attenuation curves: this can be either a combination of diffuse and birth cloud dust or just diffuse/effective birth cloud dust.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indep, prop_list (optional): See run_dust_modules for description</span>
<span class="sd">        img_name: String</span>
<span class="sd">            Name for image; a basic name is given in case none is provided</span>
<span class="sd">        img_dir: String</span>
<span class="sd">            Name for image directory; default is DustAttnCurves</span>
<span class="sd">        max_num_plot: Integer</span>
<span class="sd">            In case several points in the independent parameter space are provided, this is the maximum number of plots that will be made (to avoid inundation of files)</span>
<span class="sd">        plot_tau: Boolean</span>
<span class="sd">            Whether dust should be plotted (no plots will be made if this is False or 0)</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        dac, dac1: Arrays of same dimension of indep (but different shape); 1st dimension is different samples from the model; 2nd to 2nd last dimension (typically just 1 dimension in total) correspond to the different galaxies; last dimension corresponds to the wavelength array</span>
<span class="sd">            Dust attenuation curve as a function of wavelength (set at self.wv_arr, which is set at initialization)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mkpath</span><span class="p">(</span><span class="n">img_dir</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">img_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img_name_base</span> <span class="o">=</span> <span class="s1">&#39;DustAttnCurve&#39;</span>
            <span class="n">img_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">img_name_base</span><span class="si">}</span><span class="s1">_bv_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bivar</span><span class="si">}</span><span class="s1">_eff_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">img_name_full</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">img_dir</span><span class="p">,</span><span class="n">img_name</span><span class="p">)</span>
        <span class="n">nvals</span><span class="p">,</span> <span class="n">tauvals</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_dust_modules</span><span class="p">(</span><span class="n">indep</span><span class="p">,</span><span class="n">prop_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bivar</span><span class="p">:</span> <span class="n">tauvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indep_samp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="kc">None</span><span class="p">,:],</span><span class="nb">len</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nvals</span><span class="o">.</span><span class="n">shape</span><span class="p">);</span> <span class="n">sh</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wv_arr</span><span class="p">));</span> <span class="n">sh</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
        <span class="n">dac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">:</span> <span class="n">dac1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">dac1</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">min</span><span class="p">(</span><span class="n">max_num_plot</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nvals</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">:</span>
            <span class="n">d1vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">tau_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_d1</span><span class="p">(</span><span class="n">tauvals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nvals</span><span class="p">)):</span> <span class="n">d1vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_d1</span><span class="p">(</span><span class="n">tauvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tau_sim</span><span class="o">=</span><span class="n">tau_sim</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">nvals</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
            <span class="n">dac</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_dust_attn_curve_d2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wv_arr</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">nvals</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="n">d2</span><span class="o">=</span><span class="n">tauvals</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">:</span> <span class="n">dac1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_dust_attn_curve_d1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wv_arr</span><span class="p">,</span> <span class="n">d1</span><span class="o">=</span><span class="n">d1vals</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">indprop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inds</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indep_lab</span><span class="p">[</span><span class="n">indprop</span><span class="p">]</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;$=</span><span class="si">%.2f</span><span class="s1">$; &#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indep_samp</span><span class="p">[</span><span class="n">indprop</span><span class="p">,</span><span class="n">ind</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">plot_tau</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">:</span> <span class="n">plotDustAttn</span><span class="p">(</span><span class="n">nvals</span><span class="p">[:,</span><span class="n">ind</span><span class="p">],</span><span class="n">tauvals</span><span class="p">[:,</span><span class="n">ind</span><span class="p">],</span><span class="n">img_name_full</span><span class="o">+</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">wv_arr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot_tau</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective</span><span class="p">:</span> <span class="n">plotDust12</span><span class="p">(</span><span class="n">d1vals</span><span class="p">[:,</span><span class="n">ind</span><span class="p">],</span><span class="n">tauvals</span><span class="p">[:,</span><span class="n">ind</span><span class="p">],</span><span class="n">img_name_full</span><span class="o">+</span><span class="s1">&#39;_</span><span class="si">%02d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">nvals</span><span class="p">[:,</span><span class="n">ind</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">wv_arr</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dac</span><span class="p">,</span> <span class="n">dac1</span></div>
                
<div class="viewcode-block" id="DustAttnCalc.get_indep_lims"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.get_indep_lims">[docs]</a>    <span class="k">def</span> <span class="nf">get_indep_lims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Print and return reasonable mins and maxs for independent parameters &quot;&quot;&quot;</span>
        <span class="n">mins</span><span class="p">,</span> <span class="n">maxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">prop_dict</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mins:&quot;</span><span class="p">,</span> <span class="n">mins</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maxs:&quot;</span><span class="p">,</span> <span class="n">maxs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mins</span><span class="p">,</span> <span class="n">maxs</span></div>

<div class="viewcode-block" id="DustAttnCalc.get_like"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.get_like">[docs]</a>    <span class="k">def</span> <span class="nf">get_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dep</span><span class="p">,</span><span class="n">indep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">prop_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get likelihood of given sample of n and/or tau</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dep: 1-D, 2-D, or 3-D array</span>
<span class="sd">            Values of dependent variable(s); if bivariate model desired, distinction between n and tau should be done in the outermost dimension of the array: for example, a row of n values and a row of tau values.</span>
<span class="sd">        indep, prop_list: See run_dust_modules for description</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        like: Same size array as dep (unless bivariate case, in which one fewer dimension)</span>
<span class="sd">            Array of likelihoods</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nsim</span><span class="p">,</span> <span class="n">tausim</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">w2s</span><span class="p">,</span> <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_dust_modules</span><span class="p">(</span><span class="n">indep</span><span class="p">,</span><span class="n">prop_list</span><span class="p">)</span>
        <span class="n">like</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nsim</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bivar</span><span class="p">:</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">like</span><span class="p">)):</span>
                <span class="n">like</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">dep</span><span class="o">-</span><span class="n">nsim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">like</span><span class="p">)):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">nsim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tausim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">w2s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">rs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">nsim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tausim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">w2s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">like</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">w2s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">rs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">z</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">rs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">like</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="DustAttnCalc.get_weights"><a class="viewcode-back" href="../DustAttnCalc.html#DustAttnCalc.DustAttnCalc.get_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dep</span><span class="p">,</span><span class="n">indep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">prop_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get weights of samples of dependent variables (observations) based on the hierarchical Bayesian dust model vs Prospector priors. See get_like for description of arguments &quot;&quot;&quot;</span>
        <span class="n">like</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_like</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span><span class="n">indep</span><span class="p">,</span><span class="n">prop_list</span><span class="p">)</span>
        <span class="n">myclip_a</span><span class="p">,</span> <span class="n">myclip_b</span><span class="p">,</span> <span class="n">my_mean</span><span class="p">,</span> <span class="n">my_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">taustr</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">taustr</span><span class="p">],</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">myclip_a</span> <span class="o">-</span> <span class="n">my_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">my_std</span><span class="p">,</span> <span class="p">(</span><span class="n">myclip_b</span> <span class="o">-</span> <span class="n">my_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">my_std</span>
        <span class="n">n_wid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">nstr</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dep_dict</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">nstr</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bivar</span><span class="p">:</span> 
            <span class="n">prprior</span> <span class="o">=</span> <span class="n">truncnorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="n">my_mean</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">my_std</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_wid</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">like</span> <span class="o">/</span> <span class="n">prprior</span>
        <span class="k">else</span><span class="p">:</span>  
            <span class="n">weight</span> <span class="o">=</span> <span class="n">like</span><span class="o">*</span><span class="n">n_wid</span>
        <span class="k">return</span> <span class="n">weight</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">DustE</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Gautam Nagaraj, John Forbes, Dan Foreman-Mackey, Joel Leja, Christopher Hayward.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>